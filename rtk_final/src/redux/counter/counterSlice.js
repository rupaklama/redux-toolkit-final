import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  value: 0,
  status: 'idle',
};

// Redux Toolkit allows us to write "mutating" logic in reducers. It
// doesn't actually mutate the state because it uses the Immer library,
// which detects changes to a "draft state" and produces a brand new
// immutable state based off those changes
export const counterSlice = createSlice({
  // unique name for our 'slice' - piece of state
  name: 'counter',

  initialState,

  // The `reducers` field lets us define reducers and generate associated actions
  // setting up 'reducers' & 'actions' at the same time
  reducers: {
    // Here the Keys are Actions
    increment: state => {
      state.value += 1;
    },
    decrement: state => {
      state.value -= 1;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    // second arg is the action object
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {},
});

// Note: Slice will automatically/dynamically give us Action Types - Action Creators
// Note: These are NOT reducers functions above.
// These are Action Creators with the same name as reducers.
// you can change name by doing - increment: incrementAction
export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// Reducer
// It is a convention to export reducer as a default export
export default counterSlice.reducer;
